//! Licensed to the .NET Foundation under one or more agreements.
//! The .NET Foundation licenses this file to you under the MIT license.
(function(){"use strict";let e;const n=[["mono_wasm_register_root","number",["number","number","string"]],["mono_wasm_deregister_root",null,["number"]],["mono_wasm_string_get_data",null,["number","number","number","number"]],["mono_wasm_string_get_data_ref",null,["number","number","number","number"]],["mono_wasm_set_is_debugger_attached","void",["bool"]],["mono_wasm_send_dbg_command","bool",["number","number","number","number","number"]],["mono_wasm_send_dbg_command_with_parms","bool",["number","number","number","number","number","number","string"]],["mono_wasm_setenv",null,["string","string"]],["mono_wasm_parse_runtime_options",null,["number","number"]],["mono_wasm_strdup","number",["string"]],["mono_background_exec",null,[]],["mono_set_timeout_exec",null,[]],["mono_wasm_load_icu_data","number",["number"]],["mono_wasm_get_icudt_name","string",["string"]],["mono_wasm_add_assembly","number",["string","number","number"]],["mono_wasm_add_satellite_assembly","void",["string","string","number","number"]],["mono_wasm_load_runtime",null,["string","number"]],["mono_wasm_exit",null,["number"]],["mono_wasm_change_debugger_log_level","void",["number"]],["mono_wasm_get_corlib","number",[]],["mono_wasm_assembly_load","number",["string"]],["mono_wasm_find_corlib_class","number",["string","string"]],["mono_wasm_assembly_find_class","number",["number","string","string"]],["mono_wasm_runtime_run_module_cctor","void",["number"]],["mono_wasm_find_corlib_type","number",["string","string"]],["mono_wasm_assembly_find_type","number",["number","string","string"]],["mono_wasm_assembly_find_method","number",["number","string","number"]],["mono_wasm_invoke_method","number",["number","number","number","number"]],["mono_wasm_invoke_method_ref","void",["number","number","number","number","number"]],["mono_wasm_string_get_utf8","number",["number"]],["mono_wasm_string_from_utf16_ref","void",["number","number","number"]],["mono_wasm_get_obj_type","number",["number"]],["mono_wasm_array_length","number",["number"]],["mono_wasm_array_get","number",["number","number"]],["mono_wasm_array_get_ref","void",["number","number","number"]],["mono_wasm_obj_array_new","number",["number"]],["mono_wasm_obj_array_new_ref","void",["number","number"]],["mono_wasm_obj_array_set","void",["number","number","number"]],["mono_wasm_obj_array_set_ref","void",["number","number","number"]],["mono_wasm_register_bundled_satellite_assemblies","void",[]],["mono_wasm_try_unbox_primitive_and_get_type_ref","number",["number","number","number"]],["mono_wasm_box_primitive_ref","void",["number","number","number","number"]],["mono_wasm_intern_string_ref","void",["number"]],["mono_wasm_assembly_get_entry_point","number",["number"]],["mono_wasm_get_delegate_invoke_ref","number",["number"]],["mono_wasm_string_array_new_ref","void",["number","number"]],["mono_wasm_typed_array_new_ref","void",["number","number","number","number","number"]],["mono_wasm_class_get_type","number",["number"]],["mono_wasm_type_get_class","number",["number"]],["mono_wasm_get_type_name","string",["number"]],["mono_wasm_get_type_aqn","string",["number"]],["mono_wasm_event_pipe_enable","bool",["string","number","string","bool","number"]],["mono_wasm_event_pipe_session_start_streaming","bool",["number"]],["mono_wasm_event_pipe_session_disable","bool",["number"]],["mono_wasm_string_from_js","number",["string"]],["mono_wasm_exit","void",["number"]],["mono_wasm_set_main_args","void",["number","number"]],["mono_wasm_enable_on_demand_gc","void",["number"]],["mono_profiler_init_aot","void",["number"]],["mono_wasm_exec_regression","number",["number","string"]],["mono_wasm_invoke_method_bound","number",["number","number"]],["mono_wasm_write_managed_pointer_unsafe","void",["number","number"]],["mono_wasm_copy_managed_pointer","void",["number","number"]],["mono_wasm_i52_to_f64","number",["number","number"]],["mono_wasm_u52_to_f64","number",["number","number"]],["mono_wasm_f64_to_i52","number",["number","number"]],["mono_wasm_f64_to_u52","number",["number","number"]]],t={};for(const r of n){const n=t;n[r[0]]=function(...t){const o=e.cwrap(r[0],r[1],r[2],r[3]);return n[r[0]]=o,o(...t)}}const r=undefined;function o(e,n,t){function r(t,r,o){return function(...s){try{let n=s[0];if(void 0===n)n="undefined";else if(null===n)n="null";else if("function"===typeof n)n=n.toString();else if("string"!==typeof n)try{n=JSON.stringify(n)}catch(e){n=n.toString()}"string"===typeof n&&(n=`[${e}] ${n}`),r(o?JSON.stringify({method:t,payload:n,arguments:s}):[t+n,...s.slice(1)])}catch(e){n.error(`proxyConsole failed: ${e}`)}}}const o=n,s=["debug","trace","warn","info","error"];for(const e of s)"function"!==typeof o[e]&&(o[e]=r(`console.${e}: `,n.log,false));const _=`${t}/console`.replace("https://","wss://").replace("http://","ws://"),m=new WebSocket(_);m.onopen=function(){n.log(`browser: [${e}] Console websocket connected.`)},m.onerror=function(t){n.error(`[${e}] websocket error: ${t}`,t)},m.onclose=function(t){n.error(`[${e}] websocket closed: ${t}`,t)};const i=e=>{m.readyState===WebSocket.OPEN?m.send(e):n.log(e)};for(const e of["log",...s])o[e]=r(`console.${e}`,i,true)}(new Map).remove=function(e){const n=this.get(e);return this.delete(e),n};class s extends Error{}class _ extends Error{}class m extends Error{}var i={_impl:class{get LOCK_UNLOCKED(){return 0}get LOCK_OWNED(){return 2}get STATE_IDX(){return 0}get MSG_SIZE_IDX(){return 1}get LOCK_IDX(){return 2}get STATE_SHUTDOWN(){return-1}get STATE_IDLE(){return 0}get STATE_REQ(){return 1}get STATE_RESP(){return 2}get STATE_REQ_P(){return 3}get STATE_RESP_P(){return 4}get STATE_AWAIT(){return 5}get STATE_REQ_FAILED(){return 6}get STATE_RESET(){return 7}constructor(e,n,t){this.comm=new Int32Array(e),this.msg=new Uint16Array(n),this.msg_char_len=t}async run_message_loop(e){for(;;){try{let r;do{this._wait(this.STATE_IDLE),r=Atomics.load(this.comm,this.STATE_IDX)}while(r!==this.STATE_REQ&&r!==this.STATE_REQ_P&&r!==this.STATE_SHUTDOWN&&r!==this.STATE_REQ_FAILED&&r!==this.STATE_RESET);this._throw_if_reset_or_shutdown();var n=this._read_request(),t={};try{t.result=await e(n)}catch(e){t.error_type=typeof e,t.error=f(e),console.error(`Request error: ${t.error}. req was: ${n}`)}this._send_response(JSON.stringify(t))}catch(e){if(e instanceof s){const e=Atomics.load(this.comm,this.STATE_IDX);if(e===this.STATE_SHUTDOWN)break;e===this.STATE_RESET&&console.debug("caller failed, resetting worker")}else{console.error(`Worker failed to handle the request: ${f(e)}`),this._change_state_locked(this.STATE_REQ_FAILED),Atomics.store(this.comm,this.LOCK_IDX,this.LOCK_UNLOCKED),console.debug("set state to failed, now waiting to get RESET"),Atomics.wait(this.comm,this.STATE_IDX,this.STATE_REQ_FAILED);const n=Atomics.load(this.comm,this.STATE_IDX);if(n!==this.STATE_RESET)throw new m(`expected to RESET, but got ${n}`)}Atomics.store(this.comm,this.MSG_SIZE_IDX,0),Atomics.store(this.comm,this.LOCK_IDX,this.LOCK_UNLOCKED),this._change_state_locked(this.STATE_IDLE)}const r=Atomics.load(this.comm,this.STATE_IDX),o=Atomics.load(this.comm,this.LOCK_IDX);r!==this.STATE_IDLE&&r!==this.STATE_REQ&&r!==this.STATE_REQ_P&&console.error(`-- state is not idle at the top of the loop: ${r}, and lock_state: ${o}`),o!==this.LOCK_UNLOCKED&&r!==this.STATE_REQ&&r!==this.STATE_REQ_P&&r!==this.STATE_IDLE&&console.error(`-- lock is not unlocked at the top of the loop: ${o}, and state: ${r}`)}Atomics.store(this.comm,this.MSG_SIZE_IDX,0),this._change_state_locked(this.STATE_SHUTDOWN),console.debug("******* run_message_loop ending")}_read_request(){for(var e="";;){this._acquire_lock();try{this._throw_if_reset_or_shutdown();var n=Atomics.load(this.comm,this.STATE_IDX),t=Atomics.load(this.comm,this.MSG_SIZE_IDX);if(e+=this._read_from_msg(0,t),n===this.STATE_REQ)break;this._throw_if_reset_or_shutdown(),Atomics.store(this.comm,this.MSG_SIZE_IDX,0),this._change_state_locked(this.STATE_AWAIT)}finally{this._release_lock()}this._wait(this.STATE_AWAIT)}return e}_read_from_msg(e,n){return String.fromCharCode.apply(null,this.msg.slice(e,n))}_send_response(e){if(Atomics.load(this.comm,this.STATE_IDX)!==this.STATE_REQ)throw new m("WORKER: Invalid sync communication channel state.");var n;const t=e.length;for(var r=0;;){this._acquire_lock();try{var o=this._write_to_msg(e,r,t);r+=o,Atomics.store(this.comm,this.MSG_SIZE_IDX,o),n=r===t?this.STATE_RESP:this.STATE_RESP_P,this._change_state_locked(n)}finally{this._release_lock()}if(this._wait(n),n===this.STATE_RESP)break}}_write_to_msg(e,n,t){for(var r=0,o=n;r<this.msg_char_len&&o<t;)this.msg[r]=e.charCodeAt(o),o++,r++;return o-n}_change_state_locked(e){Atomics.store(this.comm,this.STATE_IDX,e)}_acquire_lock(){for(;;){const e=Atomics.compareExchange(this.comm,this.LOCK_IDX,this.LOCK_UNLOCKED,this.LOCK_OWNED);if(this._throw_if_reset_or_shutdown(),e===this.LOCK_UNLOCKED)return}}_release_lock(){const e=Atomics.compareExchange(this.comm,this.LOCK_IDX,this.LOCK_OWNED,this.LOCK_UNLOCKED);if(e!==this.LOCK_OWNED)throw new m("CRYPTO: ChannelWorker tried to release a lock that wasn't acquired: "+e)}_wait(e){Atomics.wait(this.comm,this.STATE_IDX,e),this._throw_if_reset_or_shutdown()}_throw_if_reset_or_shutdown(){const e=Atomics.load(this.comm,this.STATE_IDX);if(e===this.STATE_RESET||e===this.STATE_SHUTDOWN)throw new s}},create:function(e,n,t){return new this._impl(e,n,t)}};async function a(e,n){const t=b(e),r=await crypto.subtle.digest(t,n);return Array.from(new Uint8Array(r))}async function u(e,n,t){const r=b(e);0===n.length&&(n=new Uint8Array([0]));const o=await crypto.subtle.importKey("raw",n,{name:"HMAC",hash:r},false,["sign"]),s=await crypto.subtle.sign("HMAC",o,t);return Array.from(new Uint8Array(s))}async function c(e,n,t,r,o){const s=b(r),_=await d(e,"PBKDF2",["deriveBits"]),m=await crypto.subtle.deriveBits({name:"PBKDF2",salt:n,iterations:t,hash:s},_,8*o);return Array.from(new Uint8Array(m))}function b(e){switch(e){case 0:return"SHA-1";case 1:return"SHA-256";case 2:return"SHA-384";case 3:return"SHA-512";default:throw new _("CRYPTO: Unknown digest: "+e)}}const l=16;async function h(e,n,t,r){const o="AES-CBC",s=e?["encrypt"]:["encrypt","decrypt"],_=await d(new Uint8Array(n),o,s),m={name:o,iv:new Uint8Array(t)},i=await(e?crypto.subtle.encrypt(m,_,new Uint8Array(r)):w(m,_,r));let a=new Uint8Array(i);return e&&(a=a.slice(0,a.length-l)),Array.from(a)}async function w(e,n,t){const r=new Uint8Array(t).slice(t.length-l),o=new Uint8Array,s=await crypto.subtle.encrypt({name:e.name,iv:r},n,o),_=new Uint8Array(s);for(let e=0;e<_.length;e++)t.push(_[e]);return await crypto.subtle.decrypt(e,n,new Uint8Array(t))}function d(e,n,t){return crypto.subtle.importKey("raw",e,{name:n},false,t)}async function g(e){const n=JSON.parse(e);if("digest"===n.func)return await a(n.type,new Uint8Array(n.data));if("sign"===n.func)return await u(n.type,new Uint8Array(n.key),new Uint8Array(n.data));if("encrypt_decrypt"===n.func)return await h(n.isEncrypting,n.key,n.iv,n.data);if("derive_bits"===n.func)return await c(new Uint8Array(n.password),new Uint8Array(n.salt),n.iterations,n.hashAlgorithm,n.lengthInBytes);throw new _("CRYPTO: Unknown request: "+n.func)}function f(e){return e instanceof Error&&void 0!==e.stack?e.stack:e}var E;o("crypto-worker",console,self.location.origin),onmessage=function(e){var n=e;void 0!==e.data&&(n=e.data),(E=i.create(n.comm_buf,n.msg_buf,n.msg_char_len)).run_message_loop(g)}})();
